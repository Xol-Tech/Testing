<!DOCTYPE html>
<html>
<head>
    <title>Retro Computer UI (External)</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; display: flex; justify-content: center; align-items: center; height: 100vh; font-family: 'Inter', monospace; }
        canvas { background-color: #000; border: 2px solid #0F0; box-shadow: 0 0 10px #0F0; border-radius: 8px; }
        /* Add a global style for the scrollbar if needed for a text input area */
        ::-webkit-scrollbar { width: 8px; height: 8px; }
        ::-webkit-scrollbar-track { background: #333; }
        ::-webkit-scrollbar-thumb { background: #0F0; border-radius: 4px; }
    </style>
</head>
<body>
    <canvas id="retroScreen"></canvas>
    <script>
        const canvas = document.getElementById("retroScreen");
        const ctx = canvas.getContext("2d");

        const COLS = 80;
        const ROWS = 25;

        let CHAR_WIDTH;
        let CHAR_HEIGHT;
        let FONT_SIZE;
        const FONT_FAMILY = "monospace";

        // This will hold the LSL Script's granted URL, parsed from the URL parameter
        let lslScriptUrl = '';

        // --- Communication setup for LSL API calls ---
        async function callLSLAPI(path, method = 'GET', body = null) {
            if (!lslScriptUrl) {
                console.error("LSL Script URL not set. Cannot call API.");
                return null;
            }

            const options = { method: method };
            if (body) {
                options.body = body;
                options.headers = { 'Content-Type': 'text/plain' }; // Or 'application/json' for JSON body
            }

            try {
                const response = await fetch(`${lslScriptUrl}${path}`, options);
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                const data = await response.text(); // LSL is currently sending plain text
                return data;
            } catch (error) {
                console.error(`Error calling LSL API at ${path}:`, error);
                // Optionally display error on screen
                printString(`LSL Error: ${error.message}`, 0, ROWS - 2, "red");
                return null;
            }
        }

        // --- Retro Terminal Core Logic ---
        let screenBuffer = [];
        let cursorX = 0;
        let cursorY = 0;
        let frameCounter = 0;
        let currentInputLine = "";
        let acceptingInput = false;

        function setCanvasAndCharDimensions() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            CHAR_WIDTH = canvas.width / COLS;
            CHAR_HEIGHT = canvas.height / ROWS;
            FONT_SIZE = Math.max(1, CHAR_HEIGHT * 0.8);
            ctx.font = `${FONT_SIZE}px ${FONT_FAMILY}`;
            renderScreen(); // Redraw immediately on resize
        }

        function initScreenBuffer() {
            for (let y = 0; y < ROWS; y++) {
                screenBuffer[y] = [];
                for (let x = 0; x < COLS; x++) {
                    screenBuffer[y][x] = { char: " ", color: "#0F0" };
                }
            }
        }

        function printChar(char, col, row, color = "#0F0") {
            if (col >= 0 && col < COLS && row >= 0 && row < ROWS) {
                screenBuffer[row][col] = { char: char, color: color };
            }
        }

        function printString(str, startCol, startRow, color = "#0F0") {
            let currentX = startCol;
            let currentY = startRow;
            for (let i = 0; i < str.length; i++) {
                if (currentX >= COLS) {
                    currentX = 0;
                    currentY++;
                }
                if (currentY >= ROWS) break; // Stop if exceeding screen
                printChar(str[i], currentX, currentY, color);
                currentX++;
            }
            return { x: currentX, y: currentY }; // Return final cursor position
        }

        function clearScreen() {
            initScreenBuffer();
            cursorX = 0;
            cursorY = 0;
        }

        function scrollScreen() {
            for (let y = 0; y < ROWS - 1; y++) {
                screenBuffer[y] = screenBuffer[y + 1];
            }
            screenBuffer[ROWS - 1] = [];
            for (let x = 0; x < COLS; x++) {
                screenBuffer[ROWS - 1][x] = { char: " ", color: "#0F0" };
            }
        }

        function writeLine(line, color = "#0F0") {
            // Ensure cursorY is within bounds, scroll if needed
            while (cursorY >= ROWS - 1) { // Leave last line for input
                scrollScreen();
                cursorY = ROWS - 2; // Adjust cursor after scroll
            }
            printString(line, 0, cursorY, color);
            cursorY++;
            cursorX = 0; // Move to beginning of next line
        }

        function renderScreen() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = "#000";
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            ctx.font = `${FONT_SIZE}px ${FONT_FAMILY}`;
            ctx.textBaseline = "top";

            for (let y = 0; y < ROWS; y++) {
                for (let x = 0; x < COLS; x++) {
                    const cell = screenBuffer[y][x];
                    ctx.fillStyle = cell.color;
                    ctx.fillText(cell.char, x * CHAR_WIDTH, y * CHAR_HEIGHT);
                }
            }

            // Draw cursor
            if (acceptingInput && frameCounter % 20 < 10) {
                ctx.fillStyle = "#0F0";
                ctx.fillRect(cursorX * CHAR_WIDTH, cursorY * CHAR_HEIGHT + CHAR_HEIGHT - 2, CHAR_WIDTH, 2);
            }

            frameCounter++;
            requestAnimationFrame(renderScreen);
        }

        // --- Terminal Demo & Input Handling ---

        async function startTerminalDemo() {
            clearScreen();
            acceptingInput = false;
            await callLSLAPI("/api/resetDemo"); // Tell LSL to reset its message index
            await displayNextLSLMessage();
        }

        async function displayNextLSLMessage() {
            const msg = await callLSLAPI("/api/nextMessage");
            if (msg === "DEMO_COMPLETE" || msg === null) {
                writeLine("Demo complete.");
                writeLine("C:\\\\> " + currentInputLine); // Prompt for input
                cursorX = "C:\\\\> ".length + currentInputLine.length;
                acceptingInput = true;
            } else {
                writeLine(msg);
                setTimeout(displayNextLSLMessage, 500); // Fetch next message after a delay
            }
        }

        async function handleCommand(command) {
            writeLine("C:\\\\> " + command); // Echo command
            const response = await callLSLAPI("/api/command", "POST", command);
            if (response) {
                response.split('\n').forEach(line => writeLine(line)); // Split multi-line responses
            } else {
                writeLine("Error communicating with LSL.", "red");
            }
            writeLine("C:\\\\> " + currentInputLine); // Prompt for next input
            cursorX = "C:\\\\> ".length + currentInputLine.length;
        }

        window.addEventListener("keydown", (e) => {
            if (!acceptingInput) return;

            if (e.key.length === 1 && e.key.match(/[a-zA-Z0-9 .,!?_/\-]/)) { // Basic alphanumeric, space, some symbols
                currentInputLine += e.key;
            } else if (e.key === "Backspace") {
                currentInputLine = currentInputLine.slice(0, -1);
            } else if (e.key === "Enter") {
                e.preventDefault(); // Prevent new line in actual browser
                const commandToExecute = currentInputLine;
                currentInputLine = ""; // Clear input for next line
                handleCommand(commandToExecute);
            }
            // Update cursor based on current input line
            const prompt = "C:\\\\> ";
            printString(prompt + currentInputLine + " ".repeat(COLS - (prompt.length + currentInputLine.length)), 0, ROWS - 1);
            cursorX = prompt.length + currentInputLine.length;
        });

        // --- Initialization ---
        setCanvasAndCharDimensions();
        initScreenBuffer();
        renderScreen(); // Start the rendering loop

        // Get LSL API URL from URL parameters
        const urlParams = new URLSearchParams(window.location.search);
        lslScriptUrl = urlParams.get('lsl_api_url');

        if (lslScriptUrl) {
            console.log("LSL API URL received:", lslScriptUrl);
            startTerminalDemo(); // Start the terminal demo once LSL URL is known
        } else {
            console.error("LSL API URL not found in URL parameters. Check your LSL script's PRIM_MEDIA_CURRENT_URL setting.");
            writeLine("Error: LSL API URL not found.", "red");
            writeLine("Check console for details.", "red");
        }
    </script>
</body>
</html>